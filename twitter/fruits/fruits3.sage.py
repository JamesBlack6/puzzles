

# This file was *autogenerated* from the file fruits3.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1 = Integer(1); _sage_const_2 = Integer(2); _sage_const_3 = Integer(3); _sage_const_12 = Integer(12); _sage_const_4 = Integer(4); _sage_const_5 = Integer(5); _sage_const_15 = Integer(15); _sage_const_36 = Integer(36); _sage_const_9 = Integer(9); _sage_const_0 = Integer(0)
import sys

N = int(sys.argv[_sage_const_1 ])

prec = int(sys.argv[_sage_const_2 ])

l1 = (_sage_const_3 -_sage_const_12 *N-_sage_const_4 *N**_sage_const_2 -(_sage_const_2 *N+_sage_const_5 )*sqrt(_sage_const_4 *N**_sage_const_2 +_sage_const_4 *N-_sage_const_15 ))/_sage_const_2 
u1 = -_sage_const_2 *(N+_sage_const_3 )*(N+sqrt(N**_sage_const_2 -_sage_const_4 ))

l2 = -_sage_const_2 *(N+_sage_const_3 )*(N-sqrt(N**_sage_const_2 -_sage_const_4 ))
u2 = -_sage_const_4 *(N+_sage_const_3 )/(N+_sage_const_2 )

#print(l1,u1,l2,u2)

R = QQ['a, b, c']; (a, b, c,) = R._first_ngens(3)
cubic = a*(a+c)*(a+b)+b*(b+c)*(a+b)+c*(b+c)*(a+c)-N*(a+b)*(a+c)*(b+c)
E = EllipticCurve_from_cubic(cubic, morphism=False)

f = EllipticCurve_from_cubic(cubic, morphism=True)
finv = f.inverse()

ES = E.short_weierstrass_model()
F = ES.change_weierstrass_model([_sage_const_3 ,_sage_const_12 *N**_sage_const_2 +_sage_const_36 *N-_sage_const_9 ,_sage_const_0 ,_sage_const_0 ])

w = E.isomorphism_to(F)
winv = F.isomorphism_to(E)

RF = RealField(prec)
G = F.change_ring(RF)

generators = F.gens()
rank = len(generators) #F.rank()
torsion_order = F.torsion_order()

print("torsion order = %s" %(torsion_order))
print("rank = %s" %(rank))
print("generators = %s" %(generators))

tp = F.torsion_points()
print

if (rank > _sage_const_1 ):
    print("Associated elliptic curve has rank > 1")
    good = []
    for g in generators:
        if (g[_sage_const_0 ] < _sage_const_0 ):
            good += [g]

    if len(good)>_sage_const_0 :
        print(good)
        print("At least one generator lies on the egg")
        g = good[_sage_const_0 ]
        exit()
    else:
        print("No generators lie on the egg, not solvable")
        exit()
		
elif (rank == _sage_const_0 ):
    print("Associated elliptic curve has rank 0")
    print("No solution")
    exit()
else:
    print("Associated elliptic curve has rank 1")
    g = generators[_sage_const_0 ]
    if not(g[_sage_const_0 ] < _sage_const_0 ):
        print("Generator does not lie on egg, not solvable")
        exit()
    else:
        print("Generator lies on egg, solvable")

gg = G([RF(g[_sage_const_0 ]),RF(g[_sage_const_1 ]),RF(g[_sage_const_2 ])])
m = _sage_const_1 
tu = tp[_sage_const_0 ]
p = gg
found = False
while True: #not(p[0]>l1 and p[0]<u1) and not(p[0]>l2 and p[0]<u2):
    for t in tp:
        r = p+G(t)
        if (r[_sage_const_0 ]>l1 and r[_sage_const_0 ]<u1) or (r[_sage_const_0 ]>l2 and r[_sage_const_0 ]<u2):
            #print(m,r[0],float((m*g+t)[0]))
            tu = t
            found = True
            break
    if found:
        break
    m += _sage_const_1 
    p += G(g)

print
print("m = %s" %m)
exit()
s = finv(winv(m*g+tu))

g = gcd(s[_sage_const_0 ].denom(),s[_sage_const_1 ].denom())
sa = s[_sage_const_0 ]*g
sb = s[_sage_const_1 ]*g
sc = s[_sage_const_2 ]*g

print
print("Smallest solution:")
print
print("a = %s" %sa)
print("b = %s" %sb)
print("c = %s" %sc)
print
ml = max(len(str(sa)),len(str(sb)),len(str(sc)))
print("max %s digits" %ml)

sum = sa/(sb+sc) + sb/(sa+sc) + sc/(sa+sb)
print
print("a/(b+c) + b/(a+c) + c/(a+b) = %s" %sum)

